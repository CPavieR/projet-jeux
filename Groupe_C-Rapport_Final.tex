\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{listings}


\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}
  

%ici on ajoute les images sur la même ligne (j'ai mis des images mais je pense que ça ne fonctionnera pas de votre côté pour l'instant)
\begin{minipage}[c]{.46\linewidth}
     \begin{center}
             \includegraphics[width=4cm]{logo-fds.png}
         \end{center}
   \end{minipage} \hfill
   \begin{minipage}[c]{.46\linewidth}
    \begin{center}
            \includegraphics[width=4cm]{logo-figure.png}
        \end{center}
 \end{minipage}
    \newline \newline
%ici il faudra voir pour séparer les images du titre (en l'état ils sont collés)
%on passe ici au début du code de la page de garde

    \textsc{\LARGE Faculté Des Sciences - Montpellier}\\[2cm]

    \textsc{\Large Rapport Final}\\[1.5cm]

    \HRule \\[0.4cm]
    { \huge \bfseries Projet CMI\\[0.4cm] }

    \HRule \\[2cm]
    \\[2cm]

    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        Conrath Matthieu\\
        Robert Wendy\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
       Pavie-Routaboul Clément\\
        Rebagliato Lucas\\
      \end{flushright}
    \end{minipage}

    \vfill
    {\large 17 avril 2022}
    \\
    {\url{https://github.com/CPavieR/projet-jeux}}

  \end{center}
  \end{sffamily}
\end{titlepage}

\newpage


\renewcommand*\contentsname{Sommaire}
\tableofcontents
\newpage
   \section{Introduction}
   \subsection{Généralités}
      Dans le cadre du Cursus Master en Ingénierie : informatique (CMI), nous avons réalisé un projet de groupe afin de simuler une première expérience de gestion de projet. Durant le second semestre de la première année de CMI, nous avons eu pour objectif de développer un jeu dans l'unité d'enseignement (UE) projet CMI informatique (HAI209I). Nous participions  à une séance de 3 heures par semaine le mardi, ce qui nous a permis d'avancer efficacement sur le projet, ainsi que du travail personnel régulier en dehors des cours.
      
      La réalisation de ce projet nous a demandé une mobilisation de nos connaissances algorithmiques afin de les appliquer dans la création d'un jeu fonctionnel. Nous avons aussi dû maîtriser des compétences de gestion de projet comme la régularité du travail et la gestion du temps. La durée du développement du jeu s'est étendue sur trois mois, du 18 janvier au 17 avril 2022. Durant cette période, il nous était chaque semaine demandé de réaliser un compte rendu, à rendre sur le Moodle de l'Unité d'enseignement (UE). Nous y résumions nos avancées sur le projet ainsi que les choses que nous voulions planifier pour la semaine suivante. 
      
     \subsection{Le sujet}
         Nous voulions créer un jeu de gestion d'une entreprise de fret. Ainsi, l'objectif de notre jeu consiste à  gérer une entreprise au travers de la gestion de contrats, d'employés, de fonds et d'évènements aléatoires. Des chauffeurs et des véhicules seront mis à disposition afin d'évoluer dans le jeu. Il faudra alors accomplir des missions proposées par des entreprises et faire face aux évènements aléatoires qui pourraient ralentir la croissance de l'entreprise. Le but du jeu est donc de faire grandir son nombre d'employés et le capital de son entreprise.
    \subsection{Cahier des charges}
        Le choix du jeu était libre, mais nous souhaitions pouvoir y utiliser des algorithmes vus dans le programme de l'UE algorithmique 2 (HAI201I). L'idée de notre jeu s'est alors fondée sur l'algorithme de Dijkstra, qui donne le parcours des plus courts chemins dans un graphe.
      \subsubsection{Fonctionnement général du jeu}
        En priorité, notre jeu devait permettre d'utiliser un graphe pondéré en guise de carte. Nous devions alors parcourir ce graphe d'un sommet A à un autre sommet B (représentant différentes villes) et pour cela, implémenter l'algorithme de Dijkstra. Un système de contrat comprenant la rémunération et les charges devait être mis en place. Ensuite nous ajouterions des évènements aléatoires qui pourraient soit ralentir le joueur, soit lui être bénéfiques. Enfin, nous devions inclure un système de sauvegarde pour garder en mémoire la partie du joueur.
      \subsubsection{Fonctionnalités optionnelles}
       Une fois que nous avions terminé les éléments essentiels, nous pouvions alors intégrer un système d'expérience pour les employés. Il serait également souhaitable d'ajouter une interface graphique ainsi que des sons et bruits pour ajouter une ambiance sonore au jeu.

\section{Méthode de travail}
     Dans cette section, nous verrons nos compétences que nous avions déjà acquises ainsi que celles où nous devions nous améliorer.
      \subsection{Outils utilisés}
         Pour ce projet, nous avons en grande partie utilisé le langage C, sans s’interdire d'utiliser les bibliothèques disponibles. De plus, nous avons fait en sorte que le jeu demeure compatible avec les environnements Linux et Windows. Pour une meilleure organisation, nous avons utilisé le site GitHub afin de travailler parallèlement sur le même programme.
         Les rapports ont été rédigés en LaTeX grâce au site internet  \url{https://overleaf.com}. L'organigramme de Gantt a été réalisé avec Microsoft Exel et l'organigramme de fonctionnement du programme grâce au logiciel libre Dia.\newline
        
         \includegraphics[width=3cm]{logo_C.png}
         \includegraphics[width=3cm]{logo_github.png}
         \includegraphics[width=3cm]{logo_overleaf.png}\newline
         \includegraphics[width=3cm]{Excel-logo.png}
         \includegraphics[width=3cm]{Logo_Dia.png}
         \includegraphics[width=3cm]{logo_vsCode.png}
         
         
         
    \subsection{Analyse du projet}
        Afin de réaliser ce projet, nous avons identifié ses fonctions principales ainsi que les objectifs de celles-ci :

        \begin{itemize}
            \item Affecter toutes les variables nécessaires au programme
            \item Implanter un graphe
            \item Lire dans un fichier les données externes au programme tel que le contenu du graphe
            \item Appliquer l'algorithme de Dijkstra sur ce graphe
            \item Lire un fichier de sauvegarde et permettre de le charger
            \item Permettre l'affectation de conducteur à un contrat
            \item Calculer le temps de repos du conducteur
            \item Calculer les coûts et revenus des contrats (de manière réaliste)
            \item Générer des nombres pseudo-aléatoires
            \item Tirer des évènements aléatoires et appliquer leurs conséquences à l'entreprise
            \item Mettre en place le déroulement du jeu
            
       \end{itemize}
        \newpage
    \subsection{Planification du projet}
        \paragraph{Planification : \newline\newline}
    
    
     \begin{tabular}{|l|c|r|}
         \hline
        Tâches à réaliser & Temps prévu & Répartition \\
        \hline
        Système de transport et algorithme de Dijkstra & 2-3 semaines & Clément\\
        && Matthieu\\
        \hline
         Système de frais et de revenus (avec contrats et coûts)  & 1 semaine & Wendy \\
         && Lucas\\
        \hline
         Implémentation de conducteurs avec leurs véhicules  & 1 semaine & Clément\\
         && Matthieu \\
         \hline
         Système de sauvegardes & 2 semaines & en groupe \\
          \hline
         Évènements aléatoires & 1 semaine & Wendy \\ 
         && Lucas \\
          \hline
          Expérience des conducteurs & (optionnel) & Matthieu\\
          \hline
         
        Graphismes / sons & (optionnel) & Lucas \\
        \hline
         Finitions du code et finalisation du rapport  & 1 semaine & en groupe \\
         \hline
        \end{tabular}\newline\newline
        Initialement, nous avions prévu de nous répartir le travail comme ci-dessus, nous avions donc choisi d’attribuer les tâches à réaliser en deux groupes différents. Cependant nous savions initialement que cette planification se verrait modifiée. Par exemple les évènements aléatoires ont été réalisés avec la totalité du groupe et le système de sauvegarde a été réalisé par Clément.
        
        \newpage
        \paragraph{Organisation finale et diagramme de Gantt\newline\newline}
        
        \includegraphics[width=16cm]{gantt.PNG}
    
    Ce diagramme de Gantt récapitule les objectifs que nous avons réalisés à l’exception de l’aspect graphique qui n’a pas pu être fini. Pour résumer, nous avons commencé par réaliser les
    fonctions essentielles au fonctionnement basique du jeu : les fonctions qui nous permettront d’initialiser les données initiales du jeu. 
    \newpage
    Les 4 premières semaines ont donc été consacrées à l’ouverture et à la lecture d’un fichier en «.csv», la création du «.csv», la génération du conducteur aléatoire (avec des noms prédéfinis et des coûts au kilomètre compris dans un intervalle prédéfini), au déplacement de ces derniers et enfin à la génération d'une matrice pour stocker notre graphe.Ainsi, à la séance 4, nous pouvions déjà réaliser les actions principales du jeu comme déplacer un conducteur d’un point A à B.\newline
    Durant la séance 5 nous avons commencé à équilibrer notre jeu avec l’instauration de jours de repos afin d’éviter que les conducteurs puissent enchaîner des contrats sans contreparties. Nous avons également commencé l'implémentation de l'algorithme de Dijkstra dans le même temps.\newline
    À la séance 6, nous avons créé le début d'une boucle principale du jeu (la fonction main) et nous avons aussi ajouté le système de sauvegarde et une fonction pour ajouter des conducteurs. Enfin les séances 7 et 8 ont principalement été utilisées afin de corriger les problèmes techniques et d'équilibrage de notre jeu.
        
        
        
\subsection{Méthodologie}
Afin d'être efficaces, nous avons décidé de ne pas travailler à plusieurs sur une même portion du code en même temps. Pour ce faire, nous avons découpé notre code C en différentes bibliothèques. Chacun d'entre nous était chargé d'en coder une voire plusieurs.
Nous avons ensuite mis en commun tout le code et fabriqué la fonction principale du programme.
\newline
Lorsqu'une portion du code nécessite une fonction définie dans la bibliothèque d'une autre personne, chacun se met d'accord en premier lieu sur une signature de fonction à respecter. Le service web d'hébergement GitHub nous a permis ne communiquer et de nous coordonner très facilement avec des commentaires dans nos codes et/ou ajouts de code, nous pouvions alors savoir quand et qui avait ajouté quel code et dans quel but.\newline \newline 
Exemple dans notre github:\newline
\includegraphics[width=16cm]{capture_git.png}
\newpage
\subsection{Organisation du code du programme}
\paragraph{\newline\newline}
\includegraphics[width=16cm]{diagramme-biblio.png}
\paragraph{\newline\newline}
Ci-dessus figure un organigramme de l'organisation du code du programme et de ses bibliothèques. On y voit ici les différentes portions du code, leur contenu ainsi que leur dépendance.



 \newpage
 
\section{Développement}
    \subsection{Le graphe}
        La première tâche à effectuer était l'implémentation du graphe qui allait servir à modéliser les villes.
        Les premières implémentations de celui-ci existaient sous la forme d'un champ de bits contenant :
        

        \begin{itemize}
            \item un identifiant unique de type int
            \item le nom de la ville
            \item le nombre de villes adjacentes
            \item une liste d'adjacence contenant les identifiants des villes adjacentes
        \end{itemize}
        Cependant, cette implémentation semblait très lourde à créer et à manipuler,
        trouver le nom d'une ville à partir de son identifiant demandant de parcourir toutes les villes.
        Ultérieurement nous avons amélioré cette implémentation, les noms des villes étaient maintenant enregistrés dans un tableau de String, l'indice représentant l'identifiant de la ville.
        Néanmoins, les autres opérations restaient très lourdes à effectuer, par exemple trouver la liste d'adjacence d'une certaine ville, demandant de parcourir encore une fois toutes les villes.
        Il a donc été décidé d'implémenter les listes d'adjacence par une matrice, cette matrice permettrait de tester immédiatement l'appartenance d'une ville a la liste d'adjacente d'une autre ville.
        L'index représentant encore une fois l'identifiant de la ville.
        La matrice est implémentée grâce à un tableau de tableaux d'entiers (int).
        Afin de permettre une meilleure adaptation du tableau des noms ainsi que de la matrice, leurs créations sont réalisées en utilisant comme taille une constante NOMBRE\_DE\_VILLES, définie en début de code, permettant ainsi de facilement changer la taille de ceux-ci. Cette partie a été réalisée par Clément Pavie Routaboul.
    \subsection{Le contenu du graphe}
        Le contenu du graphe est enregistré dans un fichier externe au programme.
        Ce fichier contient les identifiants, les noms, ainsi que la liste d'adjacence pondérée des villes.
        Comme ces données sont enregistrées dans un fichier à part, il devient alors aisé de modifier ces données voire même d'échanger les données du graphe par celle d'un autre.
        Dans un souci de réalisme, nous voulions que les distances correspondent à la distance d'un tel trajet.
        Nous avions réfléchi à utiliser un programme python combiné à l'interface de programmation d'application (API) d'un logiciel de calcul d'itinéraire routier afin de générer de telles données.
        Cependant, cette tâche demandant l'utilisation d'une API que nous ne maîtrisions pas, l'idée a été abandonnée.
        La recherche et saisie de ces données ont donc été réalisées à la main, les villes étant considérées comme adjacentes lorsqu'il existait une autoroute directe entre les deux.
        Le poids des arêtes du graphe étant le nombre de kilomètres d'autoroute les séparant.
        Cette partie a été réalisée par Matthieu Conrath.
        
    \newpage
        
    \subsection{Fonctions de conversions}
        Afin de pouvoir importer le contenu du graphe, il a été nécessaire de développer des fonctions afin de convertir des chaînes de caractères en nombre. Deux fonctions ont été développées dans cette perspective. Une troisième fut créée plus tard pour l'import de sauvegarde.
        La première de ces fonctions permet de convertir une chaîne de caractère en un seul nombre.
        Dans un premier temps, on récupère la taille de la chaîne de caractères grâce à la fonction strlen.
        Ensuite on initialise une somme de type entier à 0.
                \begin{lstlisting}
       int get_num_from_charac(char characters[])
{
    int k = strlen(characters);
    int somme = 0;  
                \end{lstlisting}
                Ensuite, on boucle pour chaque caractère de la chaîne de caractère. Dans chacun de ces tours de boucle, on multiplie somme par dix afin d'augmenter la puissance de 10 des chiffres déjà lus, et on y ajoute le caractère lu moins 48, ce qui convertit le code ASCII d'un nombre en ce nombre.
                
                        \begin{lstlisting}
    for (int i = 0; i < k; i++) // pour chaque chiffres
    {

        somme = somme * 10 + characters[i] - 48; // on convertit 
        //ceux ci (-48) et on ajoute ceux ci a la somme en 
        //prenant en compte les puissance de dix
        // printf("somme = %d",somme);
    }
                \end{lstlisting}
                On retourne ensuite la somme.
                
                
                                        \begin{lstlisting}
    return somme;
}
                \end{lstlisting}
                La seconde fonction de conversion permet de convertir une chaîne de caractère en un tableau de nombre.
                Tout d'abord on récupère la longueur de la chaîne de caractère à convertir.
                Ensuite on initialise les variables suivantes à 0 : i qui représente le numéro du caractère que l'on regarde, number\_number qui est le nombre de nombres convertit jusqu'à maintenant et somme\_case qui est la somme du nombre en train d'être convertit.
                
                
                
                
                                \begin{lstlisting}
int get_list_of_int_from_list_of_char(char char_list[], 
int *liste_a_rendre)
{

    int k = strlen(char_list);
    short i = 0;
    short number_number = 0;
    int somme_case = 0;
                \end{lstlisting}
                Ensuite, tant qu'il reste des caractères que l'on n’a pas regardés, on regarde si ce caractère est '[' ou ','. Ces deux caractères étant les délimiteurs que nous avons choisis. Si l'un de ces caractères est présent, alors un nombre suit immédiatement celui-ci. Si l'on ne rencontre pas de caractère délimitant, on incrémente i.
                
                        \begin{lstlisting}
    while (i < k)
    {
        if (char_list[i] == '[' || char_list[i] == ',') 
        {
            ...
        }
        else
        {
            i++;
        }
    }
                \end{lstlisting}
                Si l'on détecte qu'un nombre commence, on remet à 0 la somme de la case et on incrémente i.
                Ensuite, tant que le i-ème caractère est un chiffre, on applique la même méthodologie que pour la fonction de conversion précédemment définie et on incrémente i.
                Ensuite, on inscrit ce nombre dans la liste de nombre a rendre.
                
                
                                        \begin{lstlisting}
            i++;
            somme_case = 0;
            while (isdigit(char_list[i]))
            {
                somme_case = somme_case * 10 + char_list[i] - 48; 
                i++;
            }
            liste_a_rendre[number_number] = somme_case;
            number_number++;
                \end{lstlisting}
                
                On retourne ensuite le nombre de nombres qui ont été lus.
                
                
                                                       \begin{lstlisting}
    return number_number;
}
                \end{lstlisting}

                La troisième fonction de conversion a été réalisée plus tard, en effet celle-ci permet de convertir les chaînes de caractère en nombre flottant ce qui n'a été nécessaire que pour le chargement d'une sauvegarde.
                Dans un premier temps, on récupère la taille de la chaîne de caractère. Ensuite, on initialise l'entier i à 0, i étant l'indice du caractère que l'on regarde.
                Les nombres flottants cent et somme sont respectivement la partie décimale du nombre qu'on lit et sa partie entière.
                 \begin{lstlisting}
float get_float_from_charac(char characters[])
{
    int k = strlen(characters);
    float somme = 0.;
    float cent = 0.;
    int i = 0;
                \end{lstlisting}
                Ensuite tant que i reste inférieur à la taille de la chaîne de caractère et que le code ASCII du i-ème caractère n'est pas 46, c'est-a-dire un point, on considère alors que l'on se trouve dans la partie entière du nombre flottant et l'on convertit celle-ci en un entier.
                
                
                                        \begin{lstlisting}
    while (i < k && characters[i] != 46)
    {

        somme = somme * 10 + characters[i] - 48; prenant en compte les puissance de dix
        i = i + 1;
        // printf("unite : %f\n", somme);
    }
                \end{lstlisting}
                Ensuite, on incrément i de 1, car si l'on a bien rencontré un point, on doit alors sauter celui-ci. On définit ensuite une limite de lecture, nous avons décidé que les décimales au-delà de 1/100 n'étaient pas nécessaires. 
                
                Alors tant que i reste inférieur à la longueur de la chaîne et à la limite que l'on s'est donnée,
                on convertit la partie flottante comme si elle était entière.
                
                
                
                
                                \begin{lstlisting}
    i = i + 1;
    // printf("unite fini : %f\n", somme);
    int limite = i + 2;
    while (i < k && i < limite)
    {
        cent = cent * 10 + characters[i] - 48;
        i++;
        // printf(" virgule : %f\n", cent);
    }
                \end{lstlisting}
                Puis, on divise cent par 100 pour en faire la partie décimale du nombre lu, car la limite de chiffre lu après la virgule est de 2.
                Enfin, on additionne somme et cent et on renvoie le résultat. 
                
                \begin{lstlisting}
    cent = cent / 100.;
    somme = somme + cent;
    return somme;
                \end{lstlisting}
    \subsection{Import du graphe}
        Il a ensuite été nécessaire d'importer les données de ce fichier dans le programme, cela a été réalisé en ouvrant le fichier contenant les données, en lisant ligne par ligne celui-ci, et en interprétant les données lues.
        \begin{lstlisting}
        void import_csv(char *nom_ville[NOMBRE_DE_VILLES], 
        int matrice_adja[NOMBRE_DE_VILLES][NOMBRE_DE_VILLES])
/**
 * cette fonction importera toutes les variables stockees dans le 
 * fichier .csv
 * elle prend en entree les pointeurs a l'endroit ou l'on 
 * voudra stocker le resultat
 * 1 pointeur tableau noms des ville
 * 2 pointeur matrice d'adjacence pondere
 */
{
    int id = 0; // initialisations des variables
    FILE *document;
    document = fopen("villes.csv", "r");
    char tab[4096];\end{lstlisting}
        on lit le fichier ligne par ligne jusqu'à que la lecture échoue
        \begin{lstlisting}
    while (fgets(tab, sizeof(tab), document))
    {        \end{lstlisting}
        On délimite la chaîne de caractères,
        on attend 4 champs : identifiant, nom, les voisins et le coût des voisins.
        \begin{lstlisting}
        char *mots = strtok(tab, ";");   
                \end{lstlisting}
        On récupère l'identifiant de la ville que l'on est en train de lire grâce à une autre fonction qui permet d'obtenir le numéro lié au nom de la ville.
        \begin{lstlisting}
        id = get_num_from_charac(mots);  
                        \end{lstlisting}
        On récupère le nom de la ville et on l'enregistre dans un tableau de tableau de caractères alloué dynamiquement.
        \begin{lstlisting}
        mots = strtok(NULL, ";");                         

        nom_ville[id] = (char *)malloc(strlen(mots) + 1); 
\end{lstlisting}
        On vérifie que l'allocation a fonctionné puis on copie le nom dans la chaîne de caractères alloué
        \begin{lstlisting}
        if(nom_ville[id]==NULL){
            printf("erreur, pas assez de memoire");
            exit(1);
        }
        strcpy(nom_ville[id], mots);        
        \end{lstlisting}
        On récupère les identifiants des villes adjacentes et le poids de ces arêtes et on les insère dans la matrice grâce à une autre fonction.
        \begin{lstlisting}
        char *li_voisin = strtok(NULL, ";");

        char *voisin_cout = strtok(NULL, ";");

        insert_voisin(id, li_voisin, voisin_cout, matrice_adja); 
        fflush(NULL);  
    }
    fclose(document); // on ferme le document
};
\end{lstlisting}

Voici maintenant la fonction d'insertion dans la matrice.
Cette fonction prends en paramètre, un identifiant de ville, deux tableaux de caractères contenant des listes d'entiers, par exemple : [245,591,566,348],
et un pointeur vers la matrice d'adjacence. La fonction va écrire dans la matrice les coûts de déplacement d'une ville à une autre.
\begin{lstlisting}
void insert_voisin(int id, char *li_voisin, char *voisin_cout,
int matrice_adja[NOMBRE_DE_VILLES][NOMBRE_DE_VILLES])
{\end{lstlisting}
On crée un tableau d'entiers dont la longueur est le nombre de villes.
Une nouvelle fonction nous permet d'affecter ce tableau avec les valeurs contenues dans la chaîne de caractères.
Cette fonction renvoie le nombre d'entiers bien affecté.
\begin{lstlisting}
    int listeIdVoisin[NOMBRE_DE_VILLES];
    int k = 
    get_list_of_int_from_list_of_char(li_voisin, listeIdVoisin);

    int listeCout[NOMBRE_DE_VILLES];
    get_list_of_int_from_list_of_char(voisin_cout, listeCout); 
\end{lstlisting}
On insère ensuite chacun des coûts à l'indice correspondant dans la matrice
\begin{lstlisting}
    for (int i = 0; i < k; i++)
    {
        matrice_adja[id][listeIdVoisin[i]] = listeCout[i];
    }
}
\end{lstlisting}

        Cette partie a été réalisée par Clément Pavie Routaboul.
    \subsection{La structure conducteur}
\begin{lstlisting}        
struct conducteur {
int id;
int position;
int compteur_km;
float cout_au_km;
int jour_de_repos;
char nom[30];
};\end{lstlisting}
Cette structure de données est l'une des plus importantes de notre jeu. En effet, elle permet de stocker nos différents conducteurs ainsi que certaines variables comme les jours de repos restants du conducteur ou encore son coût/km. Beaucoup de fonctions permettent de modifier ou d'utiliser cette structure comme deplacement() ou encore soustraction-par-tour-du-repos. Cette structure possède un identifiant (id) qui est unique.

\newpage

    \subsection{L'aléatoire}
        Très rapidement dans le programme est apparu le problème de générer un nombre pseudo aléatoire.
        La première version d'une génération aléatoire applique une formule mathématique au résultat de la fonction C time() de la bibliothèque standard time. Cependant, cette manière de procéder permet de tirer un seul nombre toutes les secondes.
        Cela a été réalisé par Matthien Conrath, Wendy Robert et Lucas Rebagliato.
        \newline
        Les limitations de cette méthode nous ont poussés à chercher une meilleure procédure.
        Celle-ci a donc été remplacée par la procédure décrite sur ce site.\footnote{https://nicolasj.developpez.com/articles/libc/hasard/}.
                Cette procédure avait été intégrée au code de cette manière :
                tout d'abord, on crée une graine pour la génération des nombres aléatoires.
                Cela est nécessaire avant de générer un nombre pseudo aléatoire.
        \begin{lstlisting}
static int a;
static int *pointeur_rand = &a;
void init_random()
{
    *pointeur_rand = time(NULL);
    //on creer une graine pour la generation des nombres 
    //aleatoires.
}
\end{lstlisting}
Ensuite, pour générer les nombres pseudoaleatoire, on part du dernier nombre aléatoire tiré ou la graine si c'est le premier nombre tiré et on lui applique une formule.
Le nombre précédent est gardé en mémoire, car la  variable la contenant est statique.
\begin{lstlisting}
int int_random(void)
{

    *pointeur_rand = 
    (1103515245 * *pointeur_rand + 12345) % 2147483647;
    if (*pointeur_rand < 0)

    {
        *pointeur_rand = -*pointeur_rand;
    }
    return (*pointeur_rand);
}

        \end{lstlisting}
        Le remplacement a été réalisé par Clément Pavie Routaboul.
        
        
  \subsection{Calcul du coût des trajets}
        Les trajets effectués par nos conducteurs coûtent de l'argent a l'entreprise, de par la consommation d'essence, mais aussi par des primes aux kilomètres pour les employés et l'entretien des camions.
        Nous avons donc réalisé des recherches sur ces charges et nous avons compilé les résultats afin de définir un prix au kilomètre, celui-ci étant partiellement lié aux conducteurs, chaque conducteur ayant un coût au kilomètre propre.
        Cette partie a été réalisée par Wendy Robert et Lucas Rebagliato.
    \subsection{Calcul des jours de repos}
        Après un contrat, nous donnons à notre conducteur des jours de repos.
        Ils sont calculés simplement au kilomètre par une simple division.
        Initialement, nous donnions un jour de repos pour chaque 100 kilomètres parcouru cependant suite a un remaniement de l'équilibrage du jeu, nous avons réduit cela à un jour tous les 250 kilomètres.
        Cela a été réalisé par Matthieu Conrath.
    \subsection{Génération de nom}
        Notre projet nécessite de tirer des noms au hasard, pour les nouveaux conducteurs, mais aussi pour les noms des entreprises.
        Cela a été implémenté simplement en créant deux tableaux contenant des noms, l'un des noms de personne, l'autre des noms d'entreprises imaginaires, ensuite, nous tirons un nombre aléatoire, appliquons un modulo dessus et prenons le nom à cet indice.
        Cette partie a été réalisée par Wendy Robert et Lucas Rebagliato.
    
    \subsection{Algorithme de Dijsktra}
        Le déplacement des conducteurs est intégralement réalisé par l'algorithme des plus courts chemins de Dijsktra. La première tâche fut de trouver un algorithme que l'on jugeait suffisamment simple pour pouvoir l'intégrer dans notre jeu. En effet l'algorithme de notre cours d'algorithmes se permettait certains raccourcis qui n'existe pas dans le langage C. Ainsi, nous avons récupéré la méthode d'un livre de Numérique et Sciences Informatiques de terminal (Prépabac spécialité NSI rédigé par Guillaume Connan, Vojislav Petrov, Gérard Razsavolgyi et Laurent Signac). \newline
        L'algorithme est donc présenté comme ceci dans le livre:\newline\newline
        * On construit et on initialise trois listes:\newline
        \begin{itemize}
        \item La liste des sommets déjà explorés lst-e;
        \item La liste des sommets atteignables par une arête depuis un sommet déjà exploré et qui n'ont pas encore été explorés lst-v;
        \item La liste des distances à i et des pères (sommets permettant d'accéder de manière optimale au sommet cible) lst-d. Initialement, lst-d est composée de n fois [infinie,NILL] saul lst-d[racine] = [0,NILL]. La valeur infinie est utilisée pour dénoter un sommet qui n'est pas encore accessible, elle est plus grande que tout nombre, permettant des comparaisons aisées.
       \end{itemize}
        * Tant que lst-v n'est pas vide, on sélectionne le sommet s de lst-v qui a la plus courte distance à i parmi les sommets de lst-v. On supprime ce sommet de lst-v et on ajoute à lst-e.\newline
        Pour chaque voisin v de s on regarde s'il est dans lst-e. Si ce n'est pas le cas, on l'y ajoute et on met lst-d:\newline
        * S'il est présent dans lst-e,on regarde si lst-d[s][0] + distance(s,v) est inférieur à lst-d[v][0] auquel cas on remet à jour de la même façon lst-d. Lorsque lst-v est vide l'algorithme s'arrête?\newline
        * On connaît alors la plus courte distance de i à tout sommet accessible et en remontant dans l'ordre des pères, on peut reconstituer le chemin qui a cette longueur.\newline
        \begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define NOMBRE_DE_VILLE 16
 Cette fonction renvoie une valeur booleen
_Bool is_not_in(int li[NOMBRE_DE_VILLE], int val)
{
    for (int y = 0; y < NOMBRE_DE_VILLE; y++)
    {
        if (li[y] == val)
        {
            return 0;
        }
    }
    return 1;
}
\end{lstlisting}La fonction is\_not\_in permet de savoir si une valeur est dans une liste. \begin{lstlisting}
int dijkstra(int matrice[NOMBRE_DE_VILLE][NOMBRE_DE_VILLE],
             int depart, int arrivee)
{

    int lst_V[NOMBRE_DE_VILLE];  
    int lst_Av[NOMBRE_DE_VILLE]; 
    int ind_lst_Av = 0;          
    int lst_D[NOMBRE_DE_VILLE][2];

   
    for (int i = 0; i < NOMBRE_DE_VILLE; i++)
    {
        
        lst_D[i][0] = -1;

        lst_D[i][1] = 0;
    }
   
    lst_D[depart][0] = 0;
    lst_D[depart][1] = depart;
    lst_Av[ind_lst_Av] = depart;
    while (ind_lst_Av < NOMBRE_DE_VILLE)
        {
        lst_V[ind_lst_Av] = lst_Av[ind_lst_Av];
     \end{lstlisting}
     Cette partie de l'algorithme est l'initialisation des variables (les listes par exemple).
     \begin{lstlisting}  
    int ind_a_ajouter = ind_lst_Av + 1;\end{lstlisting}
    Cet indice va servir à ajouter des éléments dans la liste à voir(lst-Av).
    \newline
\begin{lstlisting}

    for (int i = 0; i < NOMBRE_DE_VILLE; i++)
        {
        if (matrice[ind_lst_Av][i] != 0)
    
            {
    \end{lstlisting} On regarde si l'élément est initialisé : \begin{lstlisting}
    if (lst_D[i][0] <0 && lst_D[i][1] == 0)
    {
    lst_D[i][0] = lst_D[ind_lst_Av][0] + matrice[ind_lst_Av][i];
    lst_D[i][1] = ind_lst_Av;
    \end{lstlisting}Si l'élément n'est pas initialisé alors on l'initialise : \begin{lstlisting}
        }else
        {
            if (lst_D[ind_lst_Av][0] + matrice[ind_lst_Av][i] < 
            lst_D[i][0])
            {
                lst_D[i][0] = lst_D[ind_lst_Av][0] + 
                matrice[ind_lst_Av][i];
                lst_D[i][1] = ind_lst_Av;
            }
        }
    }
    \end{lstlisting}
     Si un élément n'est pas dans la liste des vus(lst-V) ou dans la liste des à voir(lst-Av) alors il est ajouté dans la liste des à voir : \begin{lstlisting}
            if (is_not_in(lst_Av, ind_lst_Av) && 
            is_not_in(lst_V, ind_lst_Av)) 
            {
                lst_Av[ind_a_ajouter] = ind_lst_Av;
            }
        }
        ind_lst_Av++;
    }
    return (lst_D[arrivee][0]);
} 
  \end{lstlisting}      
\newpage
            
    \subsection{Création de la boucle principale}
        Jusqu'ici toutes les parties du code développées n'étaient pas intégrées dans un même programme. Elles ont été développées dans des fichiers séparés et testés séparément. La création de la boucle principale a donc aussi consisté en une fusion de tout le code. Les fichiers dans lesquels ont été développées ces fonctions sont devenus des bibliothèques C afin de partitionner le code. Ensuite, toutes ces bibliothèques ont été importées dans le fichier principal.
        \newline
        Nous avons ensuite codé la fonction main() du fichier principal et créé ainsi la première version fonctionnelle du projet. Comme nous nous étions mis d'accord en amont sur les signatures des différentes fonctions, cela fût rapide et peu de problèmes ont été rencontrés. Cette partie a été réalisée par Clément Pavie Routaboul.
        Une nouvelle version de la boucle principale a été réalisée à la toute fin du projet afin de mieux s'adapter aux différents éléments qui avaient été rajoutés. Celle-ci a été réalisée par Matthieu Conrath.
    \subsection{Création d'un fichier Makefile}
        Suite à la réorganisation du code en différentes bibliothèques, le processus de compilation était de plus en plus long. Il était devenu nécessaire de réaliser un fichier Makefile afin de rendre le processus de compilation moins ardu.
        Cette partie a été réalisée par Lucas Rebagliato.
    \subsection{Recrutement de nouveaux conducteurs}
        Afin de mettre en place le recrutement de nouveau conducteur, nous avons implémenté un compteur de tours. Ainsi tous les 20 tours, il sera proposé au joueur d'embaucher un nouveau conducteur, à choisir parmi trois options. Plus tard cela a été modifié, le recrutement coûtera 90 000 euros à l'entreprise. Il n'est plus possible pour le joueur d'embaucher un conducteur si l'entreprise possède un avoir inférieur à 90 000.
        Cette partie a été réalisée par Matthieu Conrath et Clément Pavie Routaboul.
    \subsection{Système de sauvegarde}
        Le système de sauvegarde permet de reprendre une partie après avoir arrêté le programme. Ce système consiste en deux fonctions principales, sauvegarder() et import\_sauvegarde().
        La fonction sauvegarder() écrit l'ensemble des variables propre à la partie dans un fichier, c'est-à-dire le capital de l'entreprise, le nombre de conducteurs et la liste des conducteurs. Elle s'exécute à chaque sortie du programme.
        Tout d'abord cette fonction va ouvrir un document en lecture seule du nom de "sauvegarde.txt", créant ainsi le fichier en question si celui-ci n'existe pas ou supprimant son contenu si le fichier existe, puis elle va écrire les informations nécessaires à la reprise de la partie plus tard.

\begin{lstlisting}
void sauvegarder(float capital, int nbr_conduc, 
struct conducteur *a)
{

    FILE * document;
    document = fopen("sauvegarde.txt", "w");


\end{lstlisting}
    Ensuite, on crée un tableau de caractères et on écrit le solde de l'entreprise dans celui-ci. On inscrit ensuite le contenu de ce tableau de caractères dans le fichier.
\begin{lstlisting}

    char str[80];

    sprintf(str, "%1.2f", capital);

    fputs(str, document);


\end{lstlisting}
    Par la suite, on écrase ce même tableau et inscrivons le nombre de conducteurs avec des délimiteurs au début et à la fin afin de le différencier du premier chiffre.
    Encore une fois on inscrit cela dans le fichier de sauvegarde.
\begin{lstlisting}
    sprintf(str, ";%d;\n", nbr_conduc);
    fputs(str, document);


\end{lstlisting}
    Après cela, pour chacun des conducteurs, on inscrit dans le même tableau toutes ses informations suivies d'un retour à la ligne, et on inscrit cela dans le fichier de sauvegarde.
\begin{lstlisting}
    for (int i = 0; i < nbr_conduc; i++)
    {
        sprintf(str, "%d;%d;%d;%f;%d;%s\n", a[i].id, 
        a[i].position, a[i].compteur_km, a[i].cout_au_km, 
        a[i].jour_de_repos, a[i].nom);
        fputs(str, document);
    }


\end{lstlisting}
Enfin, on ferme le document.

\begin{lstlisting}
    fclose(document);
\end{lstlisting}

        La fonction import\_sauvergade() lit, interprète et affecte dans le programme les données sauvegardées dans le fichier de sauvegarde. S’il existe un fichier de sauvegarde, on propose alors à l'utilisateur de le charger en début de programme.
        \newline
        Pour cette fonction, le pointeur du fichier est donné en paramètre, on crée donc un tableau afin de stocker le contenu du fichier et on le lit directement.
        \begin{lstlisting}
void import_sauvegarde(float *capital, int *nbr_conduc,
struct conducteur (*a)[10],FILE *document){
    char tab[4096];
    fgets(tab, sizeof(tab), document);}

\end{lstlisting}
    Ensuite, on utilise la fonction strok afin de sectionner le tableau de caractère grâce aux délimiteurs, c'est-à-dire les points-virgules. Le premier champ du fichier de sauvegarde est le capital de l'entreprise, qui est un nombre flottant, on utilise donc une fonction afin de convertir celui-ci en un type float et on affecte cette valeur au capital de l'entreprise.
\begin{lstlisting}
    char *mots = strtok(tab, ";");
    float capita = get_float_from_charac(mots);
    *capital = capita;
\end{lstlisting}
    Par la suite, on réutilise la fonction strok afin de passer au champ suivant. Celui-ci étant le nombre de conducteurs, on convertit le tableau de caractère lu en un entier, et on affecte cette valeur au nombre de conducteurs.
\begin{lstlisting}
    mots = strtok(NULL, ";"); 
    *nbr_conduc = get_num_from_charac(mots);
    
\end{lstlisting}
    Après cela, comme on connaît le nombre de conducteurs, on peut alors boucler sur ceux-ci. À chaque tour de boucle, on récupère un à un les attributs des conducteurs et on les affecte un à un dans le tableau de conducteur. Pour chacun de ces attributs, on les convertit. La fonction strcpy est utilisée afin de copier une chaîne de caractère, cela nous permet d'affecter le nom du conducteur.
\begin{lstlisting}
    for (int i = 0; i < *nbr_conduc; i++)
    {
        fgets(tab, sizeof(tab), document);
        char *mots = strtok(tab, ";");
        (*a)[i].id = get_num_from_charac(mots);
        mots = strtok(NULL, ";");
        (*a)[i].position = get_num_from_charac(mots);
        mots = strtok(NULL, ";");
        (*a)[i].compteur_km = get_num_from_charac(mots);
        mots = strtok(NULL, ";");
        (*a)[i].cout_au_km = get_float_from_charac(mots);
        mots = strtok(NULL, ";");
        (*a)[i].jour_de_repos = get_num_from_charac(mots);
        mots = strtok(NULL, ";");
        strcpy((*a)[i].nom, mots);
    }

\end{lstlisting}
Enfin, on ferme le document.

\begin{lstlisting}
    fclose(document);
\end{lstlisting}
        Cette partie a été réalisée par Clément Pavie Routaboul.
    \subsection{Ajout des salaires}
        Afin de verser les salaires aux conducteurs, on applique un modulo 30 au nombre de tours, si l'on obtient un 0, on verse les salaires aux conducteurs. Les salaires des conducteurs augmentent avec l'ancienneté, l'ancienneté est définie par le nombre de kilomètres qu'a parcouru le conducteur depuis son embauche.
\newpage
\section{Perspectives et conclusions}
    Enfin, nous pouvons conclure sur les perspectives ainsi que le fonctionnement du jeu et du groupe de travail.
      \subsection{Perspectives}
      Notre objectif était de réaliser un jeu de gestion d'une entreprise de fret. Jusqu’ici nous n’avons développé que les éléments indispensables au fonctionnement du jeu. Nous voudrions élargir la carte en ajoutant d'autres villes du monde, car pour l’instant le jeu ne dépasse pas les frontières françaises. Nous pourrions ainsi implémenter d’autres modes de transport, tels que des bateaux ou des avions, accessibles lorsque l’entreprise sera assez développée pour élargir son territoire. Un système de niveaux se trouverait alors le bienvenu. De plus, il faudrait mettre en place une interface graphique et ajouter des effets sonores.

      \subsection{Conclusions}
%      Grâce à ce projet CMI, nous avons acquis des compétences pour la gestion de projet. Nous avons dû faire face à certaines difficultés et cela a permis à chacun des membres du groupe de s'améliorer pour de futurs projets.
      \subsubsection{Fonctionnement du jeu}
      Il subsiste quelques problèmes dans le programme. Les lettres accentuées et caractères spéciaux ne fonctionnent pas dans tous les terminaux, il faudrait modifier le programme afin qu'il détecte si le terminal sur lequel il est lancé prend en charge les accents et caractères spéciaux et utilise alors des phrases adaptées à ce terminal.
      Aussi, le programme fait appel à des commandes du terminal, notamment, la commande clear des terminaux Linux. Cependant cette commande n'existe pas sur Windows, elle est remplacée par la commande cls, ce qui résulte en un message d'erreur à chaque fois que le programme tente d'utiliser la commande clear sur Windows.
      De plus, il serait nécessaire de réorganiser l'ensemble du programme afin de grouper les différentes fonctions du programme de manière plus cohérente.
      Ensuite, la fonction de conversion d'une chaîne de caractères en un nombre flottant ne donnera qu'un nombre précis à 1 près si le nombre lu ne comporte qu'une seule décimale.
      Malgré ces problèmes, le programme reste fonctionnel et nous n'avons pas rencontré de comportement anormal du programme lors de sa phase de test finale.
      L'interaction avec des fichiers externes ainsi que les algorithmes utilisés tels que l'algorithme de Djisktra fonctionnent sans problème.
      %mettre les points négatifs en premier puis les points positifs
      \subsubsection{Fonctionnement du groupe de travail}
       Lors de ce travail de groupe, nous avons rencontré plusieurs problèmes d'ordre organisationnel. En effet, il est arrivé à plusieurs reprises que deux personnes modifient une même fonction en même temps sur la plate-forme hébergeant le code. Ceci amenant à devoir résoudre des conflits de modification.
       De plus, des fonctions utilitaires utilisées à divers endroits du code ont été développées plusieurs fois par deux personnes différentes, car elles en avaient besoin en même temps.
       Cependant, notre organisation du travail nous a permis de travailler en autonomie simultanément sur plusieurs parties du projet. Ces différentes parties, une fois terminées, ont été faciles à mettre en commun, car nous nous étions déjà concertés à l'avance sur la signature des fonctions qui allait être utilisée dans le programme. En conclusion, en dépit de son caractère perfectible, notre méthodologie nous a permis de travailler à plusieurs sur un même projet de manière efficace.

 \newpage

\section*{Bibliographie}
    \addcontentsline{toc}{section}{Bibliographie}
    \paragraph{\newline}
       Brian W. Kernighan and Dennis M. Ritchie. The C Programming Language. Prentice Hall Professional Technical Reference, 2nd edition, 1988
       \paragraph{\newline}
Prépabac cours & entraînement - nsi, numérique \& sciences informatiques, spécialité - terminale générale (édition 2020/2021)
\paragraph{\newline}
Algorithmique - 3ème édition - de Thomas H. Cormen  (Auteur), Charles E. Leiserson (Auteur), Ronald L. Rivest  (Auteur), Clifford Stein (Auteu) -Edition Dunod -2010
\paragraph{\newline}
\url{https://zestedesavoir.com/tutoriels/755/le-langage-c-1/}

\end{document}

